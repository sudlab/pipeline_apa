##############################################################################
#
#   MRC FGU CGAT
#
#   $Id$
#
#   Copyright (C) 2009 Andreas Heger
#
#   This program is free software; you can redistribute it and/or
#   modify it under the terms of the GNU General Public License
#   as published by the Free Software Foundation; either version 2
#   of the License, or (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
###############################################################################
"""===========================
Pipeline template
===========================

:Author: Andreas Heger
:Release: $Id$
:Date: |today|
:Tags: Python

.. Replace the documentation below with your own description of the
   pipeline's purpose

Overview
========

This pipeline computes the word frequencies in the configuration
files :file:``pipeline.ini` and :file:`conf.py`.

Usage
=====

See :ref:`PipelineSettingUp` and :ref:`PipelineRunning` on general
information how to use CGAT pipelines.

Configuration
-------------

The pipeline requires a configured :file:`pipeline.ini` file.
CGATReport report requires a :file:`conf.py` and optionally a
:file:`cgatreport.ini` file (see :ref:`PipelineReporting`).

Default configuration files can be generated by executing:

   python <srcdir>/pipeline_dapars.py config

Input files
-----------

None required except the pipeline configuration files.

Requirements
------------

The pipeline requires the results from
:doc:`pipeline_annotations`. Set the configuration variable
:py:data:`annotations_database` and :py:data:`annotations_dir`.

On top of the default CGAT setup, the pipeline requires the following
software to be in the path:

.. Add any additional external requirements such as 3rd party software
   or R modules below:

Requirements:

* samtools >= 1.1

Pipeline output
===============

.. Describe output files of the pipeline here

Glossary
========

.. glossary::


Code
====

"""
from ruffus import *

import sys
import os
import sqlite3
import CGAT.Experiment as E
import CGATPipelines.Pipeline as P

# load options from the config file
PARAMS = P.getParameters(
    ["%s/pipeline.ini" % os.path.splitext(__file__)[0],
     "../pipeline.ini",
     "pipeline.ini"])

# add configuration values from associated pipelines
#
# 1. pipeline_annotations: any parameters will be added with the
#    prefix "annotations_". The interface will be updated with
#    "annotations_dir" to point to the absolute path names.
PARAMS.update(P.peekParameters(
    PARAMS["annotations_dir"],
    "pipeline_annotations.py",
    on_error_raise=__name__ == "__main__",
    prefix="annotations_",
    update_interface=True))


# if necessary, update the PARAMS dictionary in any modules file.
# e.g.:
#
# import CGATPipelines.PipelineGeneset as PipelineGeneset
# PipelineGeneset.PARAMS = PARAMS
#
# Note that this is a hack and deprecated, better pass all
# parameters that are needed by a function explicitely.

# -----------------------------------------------
# Utility functions
def connect():
    '''utility function to connect to database.

    Use this method to connect to the pipeline database.
    Additional databases can be attached here as well.

    Returns an sqlite3 database handle.
    '''

    dbh = sqlite3.connect(PARAMS["database_name"])
    statement = '''ATTACH DATABASE '%s' as annotations''' % (
        PARAMS["annotations_database"])
    cc = dbh.cursor()
    cc.execute(statement)
    cc.close()

    return dbh


# -----------------------------------------------------------------
@transform(os.path.join(PARAMS["annotations_dir"],
                        PARAMS["annotations_interface_geneset_all_gtf"]),
           regex(".+"),
           "geneset.bed")
def getGenesetBed12(infile, outfile):
    '''Convert geneset to BED12 format'''

    statement = '''python %(scriptsdir)s/gff2bed.py 
                           --bed12-from-transcripts
                            -I %(infile)s
                            -S %(outfile)s
                            -L %(outfile)s.log '''

    P.run()


# -----------------------------------------------------------------
@originate("transcripts_to_genes.txt")
def generateDaParsTranscriptsToGenes(outfile):

    statement = '''SELECT DISTINCT transcript_id, gene_id
                   FROM transcript_info'''

    data = DUtils.fetch_DataFrame(statement, connect())

    data.to_csv(outfile, header = False, index = False, sep = "\t")


# -----------------------------------------------------------------
@merge([getGenesetBed12, generateDaParsTranscriptsToGenes],
       "geneset_extracted.bed")
def getDaParsGeneset(infiles, outfile):
    ''' Process geneset to generate the input file for DaPars '''

    geneset, symbols = infiles

    statement=''' DaPars_Extract_Anno.py -b %(geneset)s
                                         -s %(symbols)s
                                         -o %(outfile)s '''

    P.run()

# -----------------------------------------------------------------
@transform("*.bam", suffix("*.bam"), ".bw")
def bam_to_bedGraph(infile, outfile):
    '''Convert alignments into depth bedGraphs '''

    genome_file = os.path.join(PARAMS['annotations_dir'],
                               PARAMS['annotations_contigs_tsv'])

    statement = ''' genomeCoverageBed -split -bg -ibam %(infile)s 
                                      -g %(genome_file)s > %(outfile)s 2> %(outfile)s.log;
                    '''

    P.run()


# -----------------------------------------------------------------
def generate_config(infiles, outfile):
    '''Generate DaPars config from template. The following parameters are 
    required in the ini:

    :param:dapars_num_least_in_group int
    :param:dapars_coverage_cufoff int
    :param:dapars_fdr_cutoff float
    :param:dapars_pdui_cutoff float
    :param:dapars_logfc_cufoff float

    '''

    template_file = os.path.join(P.snip(__file__, ".py"),
                                 "dapars_config_template.txt")
    config_template = IOTools.openFile(template_file).read()

    condition1_files, condition2_files = infiles
    condition1_files = ",".join([os.path.abspath(f) for f in condition1_files])
    condition2_files = ",".join([os.path.abspath(f) for f in condition2_files])

    dapars_outfile = os.path.join(P.snip(".dapars_config.txt", outfile),
                                  "dapars_out.tsv")
    outdir = os.path.dirname(os.path.abspath(dapars_outfile))
    dapars_outfile = os.path.basename(dapars_outfile)

    local_params = PARAMS.copy()
    local_params.update(locals)

    with IOTools.openFile(outfile, "w") as outf:
        outf.write(contig_template % local_params)


if not os.path.exists("design.tsv"):

    @follows("dapars_out.dir")
    @collate(bam_to_bedGraph,
             formatter("(?P<cell>.+)-(?P<condition>(?!WT).*)-(?P<replicate>.+).bedGraph"),
             add_inputs("{cell[0]}-WT-*.bedGraph"),
             r"dapars_out.dir/{cell[0]}-{condition[0]}.dapars_config.txt")
    def generate_dapars_config(infiles, outfile):
        generate_config(infiles, outfile)

else:
    
    @subdivide("design.tsv",
               formatter(),
               add_inputs(bam_to_bedGraph),
               ["dapars_out.dir/%s.dapars_config.txt" % line.split()[0] 
                for line in IOTools.openFile("design.tsv")
                if not line.startswith("#")])
    def generate_dapars_config(infiles, outfile):

        bedgraphs = infiles[1:]

        comparisons = [line.split() for line in IOTools.openFile("design.tsv")
                       if not line.startswith("#")]

        for name, pat1, pat2 in comparisons:
            condition1_files = [f for f in bedgraphs if re.match(f, pat1)]
            condition2_files = [f for f in bedgraphs if re.match(f, pat2)]
            generate_config([condition1_files, condition2_files], outfile)


 # -----------------------------------------------------------------
@transform(generate_dapars_config,
           regex(".+/(.+).dapars_config.txt"),
           r"dapars_out.dir/\1/dapars_out.tsv")
def run_DaPars(infile, outfile):

    statement = '''DaPars_main.py %(infile)s > %(infile)s.log'''
    P.run()   
    
        
# -----------------------------------------------------------------            
@follows(run_DaPars)
def full():
    pass


@follows(mkdir("report"))
def build_report():
    '''build report from scratch.

    Any existing report will be overwritten.
    '''

    E.info("starting report build process from scratch")
    P.run_report(clean=True)


@follows(mkdir("report"))
def update_report():
    '''update report.

    This will update a report with any changes inside the report
    document or code. Note that updates to the data will not cause
    relevant sections to be updated. Use the cgatreport-clean utility
    first.
    '''

    E.info("updating report")
    P.run_report(clean=False)


@follows(update_report)
def publish_report():
    '''publish report in the CGAT downloads directory.'''

    E.info("publishing report")
    P.publish_report()

if __name__ == "__main__":
    sys.exit(P.main(sys.argv))
